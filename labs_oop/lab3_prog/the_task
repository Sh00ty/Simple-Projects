1.Разработать класс "табличная функция" в соответствии со следующим заданием:
Состояние класса -
Класс "функция" определяет таблично заданную функцию; он включает в себя узлы (значения аргумента x и функции y типа double) и определяется количеством узлов и значениями x и y для каждого узла, например: функция из 5 узлов (1.0, 2.0), (1.5, 3.25), (2.0, 5.0), (2.5, 7.25), (3.0, 10.0). Для описания узла функции целесообразно использовать структуру. Узлы функции должны быть расположены по возрастанию значений х. Память под функцию выделяется статически, во время компиляции, и задается массивом фиксированного предельного значения (например, максимальное количество узлов функции - 20).

Протокол класса -
Определяет  возможности создания и  инициализации экземпляров класса и правила использования их (методы класса).
Предусмотреть следующие возможности:
·          пустой конструктор для инициализации экземпляров и массивов экземпляров класса по умолчанию;
·          создание экземпляров класса с инициализацией значением единственного узла (“точка”);
·          создание экземпляров класса с инициализацией количеством узлов и значениями функции в узлах;
·          ввод экземпляров класса из входного потока и вывод их значений в выходной поток;
·          определение максимального и минимального значений функции;
·          определение типа функции (убывающая, возрастающая, переменная, постоянная);
·          вычисление значения функции в некоторой точке x0 (использовать метод кусочно-линейной интерполяции);
·          добавление нового узла в функцию.
2. Проектирование класса рекомендуется начать с представления состояния класса, учитывающего заданные операции, а затем реализации конструкторов и метода вывода. Для отладки и исчерпывающего тестирования других методов разработанного класса реализовать диалоговую программу, которая позволяет вводить параметры отлаживаемых методов. Для обработки ошибочных ситуаций использовать механизм исключительных ситуаций.
3. Повторить разработку класса, реализовав отдельные методы (там, где это оправданно), перегруженными операторами. Состав перегруженных операторов целесообразно согласовать с преподавателем.
4. Еще раз повторить разработку класса при условии, что память под массив необходимой длины выделяется динамически, во время выполнения программы (с помощью оператора new; память задается указателем на char в состоянии класса). Для хранения данных в экземпляре класса не должна использоваться лишняя память.
Дополнить интерфейс класса следующими возможностями:
·          создание экземпляра класса с его инициализацией другим экземпляром класса (копирующий конструктор);
·          переопределение экземпляра класса (с помощью перегруженного оператора присваивания).
